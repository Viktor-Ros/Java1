package Other;

import java.util.ArrayList;
import java.util.Arrays;

/*
 * 
 * ЗАДАЧА ПРО СДАЧУ
 * 
 * Условие: выдать сдачу минимальным кол-вом монет имеющихся номиналов, число монет не ограничено
 * 
 * Решение: ищем оптимальное кол-во монет для каждой сдачи, от 0 до нужной сдачи
 * исходя из очевидного, что число монет для сдачи 0 равно 0 - это и будет первое условие
 * далее, опимальное кол-во монет для любой сдачи = число монет для сдачи размером(сдача - номинал монеты) + 1(монета)
 * оптимальное кол-во монет для сдачи например 6 = число монет для сдачи 5 + 1 монета, номиналом в 1
 * 
 * 
 * 
 * 
 * n - размер сдачи в рублях
 * S(n) - минимальное количество монет для n
 * V - набор монет разных номиналов
 * Vi - номинал любой монеты
 * 
 * S(n) = S(n-Vi) + 1 - рекуррентная формула
 * Мин кол-во монет для сдачи = мин кол-во монет для (сдача - номинал монеты) + монета
 * 
 * 
 * 
 */

public class TaskChange {
	
	public static void main(String[] args) {
		
		int[] coins = {1,3,5,10};// номиналы монет
		
		int s = 10;//сумма сдачи
		
        System.out.println("Сдача: " + s);
        
		int[] dp = new int[s + 1];//массив с минимальным набором монет
		
		ArrayList<Integer>[] listCoins = new ArrayList[dp.length];//массив со списками монет для сдачи
		
        Arrays.fill(dp, Integer.MAX_VALUE);//заполняем массив числами, которые явно больше любого набора монет
        
        dp[0] = 0;//первый элемент массива dp равен 0, тк для сдачи 0 не нужно монет и это будет первое мин вол-во монет от которого будем отталкиваться
        
        listCoins[0] = new ArrayList<>();//первый список
        
        for ( int i = 1; i <= s; i++) {//перебор все размеров сдач до сдачи равной s
        	
        	listCoins[i] = new ArrayList<>();//заполняем массив с наборами монет пустыми списками
        	
            for (int j = 0; j < coins.length; j++) {//перебор всех номиналов монет

                if (coins[j] <= i && dp[i - coins[j]] + 1 < dp[i]) {
                	
                	listCoins[i].clear();//чистка списка, чтобы предотвратить смешивание нескольких наборов
                	
                	//coins[j] <= i - проверяем войдет ли номинал монеты в сдачу
                	//dp[i - coins[j]] + 1 < dp[i] - та самая рекуррентная формула
                	//dp[i] - кол-во монет в данный момент времени
                	//coins[j] монета j со своим номиналом
                	// i - coins[j] - сдача без монеты coins[i]
                	//dp[i - coins[j]] + 1 - кол-во монет для сдачи без монеты coins[i], которая учтена путем +1
     
                    dp[i] = dp[i - coins[j]] + 1;
                    
                    listCoins[i].addAll(listCoins[i - coins[j]]);//добавляем в список, прошлый набор монет, который оптимален для сдачи без монеты coins[j]
                    
                    listCoins[i].add(coins[j]);//добавляем в список монету coins[j]
                }
            }
        }
        
        System.out.println("Минимум монет для сдачи: " + dp[s]);
        System.out.println("Набор монет: " + listCoins[s]);
	
	}
}